Section - Prototypical Inheritance:
-----------------------------------
Lecture 1 - Creating your own prototypical inheritance:
-------------------------------------------------------
So how does Inheritance work in JavaScript? Say we have a Circle and Square
class, and they both contain draw & duplicate methods.
We want to add these methods to a Shape Object, then inherit to any other shapes.

Task 1 - Create Shape Function
function Shape() {}

Task 2 - Add Methods to the Prototype of Shape (eg. ObjectBase)
Shape.prototype.draw = function () {
  console.log("draw");
};

Task 3 - Assign Circle & Square to the same ObjectBase.
Circle.prototype = Object.create(Shape.prototype);

Task 4 - Test
We should have full access to the shape methods now.
circle.draw()

Take Home:
Object.create(Shape.prototype) - returns an object, in this case the Shape 
prototype.

In JavaScript we use Prototype Objects to encapsulate methods, then we create
objects that point to the same prototype, achieving prototypical inheritance.


Lecture 2 - Resetting the Constructor:
--------------------------------------
So there is a problem with our previous implementation. In a previous section we went
over the constructor function, which returns the function used to create the object.
Now that we've set the Circle prototype to shape, we lose the ability to create a
plain circle object.

In order for us to fix this, we'll see to reset the constructor function to return
the shape base methods too.


Note - Best Practice, whenever you reset the prototype of an Object, you should
also reset its constructor.


Lecture 3 - Calling the Super Contructor:
-----------------------------------------
Now in this section we're going to complicate things a bit. Remember we have the Shape
parent class, if we want to set a color on a given shape, lets see how that works
when we try use the child classes like Circle.


note - When setting properties on the super constructor, be careful with scope.
When we new up a circle 3 things are done, an empty object is created, our object is 
the arguments are passed, and the object is assigned to the return object.
When we create the circle, we want to make sure the same instance of THIS is set on
the prototype.

Shape(color); - This sets color on the Global Window Obj.
Shape.call(this, color); - Passes the correct instance of THIS Obj.

Take home:
-Use Shape.call to modify the super constructor.




Lecture 4 - Intermediate Function Inheritance:
----------------------------------------------
So lets start by fleshing out a new object, the Square. Its becoming apparent the
more objects we create, the more configuration we're going to have to do e.g.

Square.prototype = Object.create(Shape.prototype);
Square.prototype.constructor = Square;

How can we simplfy this? With an Intermediate function lets go.

Task - Create Intermediate Function:
function extend(Child, Parent) {
  Child.prototype = Object.create(Parent.prototype);
  Child.prototype.constructor = Parent;
}


Task - Use Function:
We can reduce the duplication to a single function call...
Square.prototype = Object.create(Shape.prototype);
Square.prototype.constructor = Square;

like so...
extend(Square, Shape);


Take Home:
Use an Intermediate Inheritance function to avoid duplicating constructor & prototype
assignment.




Lecture 5 - Method Overriding:
------------------------------
So sometimes we might run into a slight problem, where we inherit behavior from a 
parent class, but we want to slighly modify it for a given object type.
This is where method overriding comes in handy.




note - This works because the JavaScript engine walks up the dependency tree, finds
starting at the child object. Thus it finds our new implementation first.